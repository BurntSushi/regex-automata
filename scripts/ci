#!/bin/bash

set -e

# Man I don't *want* to have this many crate features, but... I really want
# folks to be able to slim the crate down to just the things they want. But
# the main downside is that I just can't feasibly test every combination of
# features because there are too many of them. Sad, but I'm not sure if there
# is a better alternative.
# shellcheck disable=SC2054
features=(
  ""
  unicode-word-boundary
  unicode-word-boundary,syntax,unicode-perl
  unicode-word-boundary,syntax,dfa-build
  nfa
  dfa
  hybrid
  nfa,dfa
  nfa,hybrid
  dfa,hybrid
  dfa-onepass
  nfa-pikevm
  nfa-backtrack
  std
  alloc
  syntax
  syntax,nfa-pikevm
  syntax,hybrid
  perf-literal-substring
  perf-literal-multisubstring
)
for f in "${features[@]}"; do
  echo "===== FEATURES: $f ==="
  # It's actually important to do a standard 'cargo build' in addition to a
  # 'cargo test'. In particular, in the latter case, the dev-dependencies may
  # wind up enabling features in dependencies (like memchr) that make it look
  # like everything is well, but actually isn't. For example, the 'regex-test'
  # dev-dependency uses 'bstr' and enables its 'std' feature, which in turn
  # unconditionally enables 'memchr's 'std feature. Since we're specifically
  # looking to test that certain feature combinations work as expected, this
  # can lead to things testing okay, but would actually fail to build. Yikes.
  cargo build --no-default-features --lib --features "$f"
  cargo test --no-default-features --lib --features "$f"
done

# Miri is particularly slow, so we are careful what we run. Miri can't deal
# with the integration level tests at all (it's too slow to even load a TOML
# file), but we can run it on the library and doc tests. (And many which have
# been cfg'd out on Miri because of speed.)
cargo miri test --lib
cargo miri test --doc
