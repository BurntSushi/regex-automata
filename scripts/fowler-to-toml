#!/usr/bin/env python

from __future__ import absolute_import, division, print_function
import argparse
import os.path as path


def read_tests(f):
    basename, _ = path.splitext(path.basename(f))
    tests = []
    prev_pattern = None

    for lineno, line in enumerate(open(f), 1):
        fields = list(filter(None, map(str.strip, line.split('\t'))))
        if not (4 <= len(fields) <= 5) \
           or 'E' not in fields[0] or fields[0][0] == '#':
            continue

        terse_opts, pat, text, sgroups = fields[0:4]
        groups = []  # groups as integer ranges
        if sgroups == 'NOMATCH':
            groups = []
        elif ',' in sgroups:
            noparen = map(lambda s: s.strip('()'), sgroups.split(')('))
            for g in noparen:
                s, e = map(str.strip, g.split(','))
                if s == '?' and e == '?':
                    groups.append([])
                else:
                    groups.append([int(s), int(e)])
        else:
            # This skips tests that should result in an error.
            # There aren't many, so I think we can just capture those
            # manually. Possibly fix this in future.
            continue

        case_insensitive = False
        if text == "NULL":
            text = ""
        if pat == 'SAME':
            pat = prev_pattern
        if '$' in terse_opts:
            pat = pat.encode('utf-8').decode('unicode_escape')
            text = text.encode('utf-8').decode('unicode_escape')
            text = text.encode('unicode_escape').decode('utf-8')
        else:
            text = text.encode('unicode_escape').decode('utf-8')
        if 'i' in terse_opts:
            case_insensitive = True

        pat = pat.encode('unicode_escape').decode('utf-8')
        pat = pat.replace('\\\\', '\\')
        if len(groups) > 0:
            captures = '[' + str(groups) + ']'
        else:
            captures = '[]'
        test = {
            'name': '"%s%d"' % (basename, lineno),
            'regex': "'''%s'''" % pat,
            'input': "'''%s'''" % text,
            'captures': captures,
            'match_limit': '1',
            'unescape': 'true',
        }
        if case_insensitive:
            test['case_insensitive'] = 'true'
        tests.append(test)
        prev_pattern = pat
    return tests


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Generate match tests from an AT&T POSIX test file.',
    )
    aa = parser.add_argument
    aa('outdir', help='Directory to write generated TOML files.')
    aa('datfile', help='A dat AT&T POSIX test file.', nargs='+')
    args = parser.parse_args()

    for datfile in args.datfile:
        tests = read_tests(datfile)
        filename = path.basename(datfile)
        name, _ = path.splitext(filename)
        toml_path = path.join(args.outdir, f'{name}.toml')

        with open(toml_path, 'w+') as out:
            print('''
# !!! DO NOT EDIT !!!
# Automatically generated by scripts/fowler-to-toml.
# Numbers in the test names correspond to the line number of the test from
# the original dat file.
    '''.strip(), file=out)
            print(file=out)
            for t in tests:
                print('[[tests]]', file=out)
                for k, v in t.items():
                    print(f'{k} = {v}', file=out)
                print(file=out)
