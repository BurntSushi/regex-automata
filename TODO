* Consider refactoring the NFA representation such that it can be instantly
loaded from a `&[u8]`, just like a sparse DFA. Main downside is that this could
negatively impact using the NFA with deserialization costs. Before doing this,
we should write PikeVM and backtracking implementations so that they can be
benchmarked.

* Investigate why NFA shrinking seems to produce bigger DFAs after
determinization, even though it makes determinization substantially faster.
This might be because of its use of sparse NFA states, which have a lower
constant overhead associated with them.

* Scrutinize whether the SparseTransitions and Transition types should have
their representations expose. The State enum is already totally exposed...

* Provid a more elementary API for 'start_state_forward'.
See: https://github.com/rust-lang/regex/issues/852

* There is an issue where the minimum cache capacity required by the lazy DFA
is likely too big. This in turn could result in NOT using the lazy DFA even
if it would be okay. We should either fix the minimum to be closer to the
actual minimum or maybe not require a minimum? (The problem is that I think the
minimum is there to avoid runtime panics in degenerate cases...)

* There's likely some SIMD we can do to improve parts of the PikeVM.
Specifically, the Sparse state. Maybe PCMPESTI can finally be useful?
