* Consider refactoring the NFA representation such that it can be instantly
loaded from a `&[u8]`, just like a sparse DFA. Main downside is that this could
negatively impact using the NFA with deserialization costs. Before doing this,
we should write PikeVM and backtracking implementations so that they can be
benchmarked.

* Investigate why NFA shrinking seems to produce bigger DFAs after
determinization, even though it makes determinization substantially faster.
This might be because of its use of sparse NFA states, which have a lower
constant overhead associated with them.
  * IDEA: Maybe the "shrinking" part of this isn't really helping as much as
  I think, and it really is just the sparse states. So... Is there a way to
  use the faster shrinking strategy while making use of sparse states? That
  could be a really huge win.

* Scrutinize whether the SparseTransitions and Transition types should have
their representations expose. The State enum is already totally exposed...

* Provide a more elementary API for 'start_state_forward'.
See: https://github.com/rust-lang/regex/issues/852

* There is an issue where the minimum cache capacity required by the lazy DFA
is likely too big. This in turn could result in NOT using the lazy DFA even
if it would be okay. We should either fix the minimum to be closer to the
actual minimum or maybe not require a minimum? (The problem is that I think the
minimum is there to avoid runtime panics in degenerate cases...)
  * Calling this fixed. I did two things. 1) I fixed a bug in the minimum
  cache capacity calculation where state heap usage (for NFA IDs) was double
  counters. 2) I also reduced minimum state size from 5 to 4, which is the
  actual real minimum needed (I think). OK, turns out (2) doesn't work because
  5 states is the real minimum.

* There's likely some SIMD we can do to improve parts of the PikeVM.
Specifically, the Sparse state. Maybe PCMPESTI can finally be useful?

* Rename Match to Span, MultiMatch to Match and keep HalfMatch as-is (since
it does include a pattern ID).

* Prefilters. See top of src/util/prefilter.rs for more in depth thoughts.
