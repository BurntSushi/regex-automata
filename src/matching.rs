/// The kind of match semantics to use for a DFA.
///
/// The default match kind is `LeftmostFirst`.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum MatchKind {
    /// Report all possible matches.
    All,
    /// Report only the leftmost matches. When multiple leftmost matches exist,
    /// report the match corresponding to the part of the regex that appears
    /// first in the syntax.
    LeftmostFirst,
    /// Hints that destructuring should not be exhaustive.
    ///
    /// This enum may grow additional variants, so this makes sure clients
    /// don't count on exhaustive matching. (Otherwise, adding a new variant
    /// could break existing code.)
    #[doc(hidden)]
    __Nonexhaustive,
    // There is prior art in RE2 that shows that we should be able to add
    // LeftmostLongest too. The tricky part of it is supporting ungreedy
    // repetitions. Instead of treating all NFA states as having equivalent
    // priority (as in 'All') or treating all NFA states as having distinct
    // priority based on order (as in 'LeftmostFirst'), we instead group NFA
    // states into sets, and treat members of each set as having equivalent
    // priority, but having greater priority than all following members
    // of different sets.
}

impl MatchKind {
    pub(crate) fn continue_past_first_match(&self) -> bool {
        *self == MatchKind::All
    }
}

impl Default for MatchKind {
    fn default() -> MatchKind {
        MatchKind::LeftmostFirst
    }
}

/// A representation of a match reported by a regex engine.
///
/// A match records the start and end offsets of the match in the haystack.
///
/// Every match guarantees that `start <= end`.
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct Match {
    /// The start offset of the match, inclusive.
    start: usize,
    /// The end offset of the match, exclusive.
    end: usize,
}

impl Match {
    /// Create a new match from a byte offset span.
    ///
    /// # Panics
    ///
    /// This panics if `end < start`.
    #[inline]
    pub fn new(start: usize, end: usize) -> Match {
        assert!(start <= end);
        Match { start, end }
    }

    /// The starting position of the match.
    #[inline]
    pub fn start(&self) -> usize {
        self.start
    }

    /// The ending position of the match.
    #[inline]
    pub fn end(&self) -> usize {
        self.end
    }

    /// Returns true if and only if this match is empty. That is, when
    /// `start() == end()`.
    ///
    /// An empty match can only be returned when the empty string was among
    /// the patterns used to build the Aho-Corasick automaton.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.start == self.end
    }

    #[inline]
    fn offset(&self, by: usize) -> Match {
        Match { start: self.start + by, end: self.end + by }
    }
}

/// A type alias for an integer that represents a pattern identifier.
///
/// A pattern ID represents an identifier for a pattern, where the identifier
/// is generated by its relative position among other patterns. Namely, when
/// building a multi-regex engine, one must supply a sequence of patterns
/// to match. The position (starting at 0) of each pattern in that sequence
/// represents its identifier. This identifier is in turn used to identify and
/// report matches of that pattern in various APIs.
pub type PatternID = u32;

/// A representation of a multi match reported by a regex engine.
///
/// A multi match has two essential pieces of information: the identifier of
/// the pattern that matched, along with the start and end offsets of the match
/// in the haystack.
///
/// The pattern is identified by an ID, which corresponds to its position
/// (starting from `0`) relative to other patterns used to construct the
/// corresponding regex engine. If only a single pattern is provided, then all
/// multi matches are guaranteed to have a pattern ID of `0`.
///
/// Every multi match guarantees that `start <= end`.
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct MultiMatch {
    /// The pattern ID.
    pattern: PatternID,
    /// The start offset of the match, inclusive.
    start: usize,
    /// The end offset of the match, exclusive.
    end: usize,
}

impl MultiMatch {
    /// Create a new match from a pattern ID and a byte offset span.
    ///
    /// # Panics
    ///
    /// This panics if `end < start`.
    #[inline]
    pub fn new(pattern: PatternID, start: usize, end: usize) -> MultiMatch {
        assert!(start <= end);
        MultiMatch { pattern, start, end }
    }

    /// Returns the ID of the pattern that matched.
    ///
    /// The ID of a pattern is derived from the position in which it was
    /// originally inserted into the corresponding regex engine. The first
    /// pattern has identifier `0`, and each subsequent pattern is `1`, `2` and
    /// so on.
    #[inline]
    pub fn pattern(&self) -> PatternID {
        self.pattern
    }

    /// The starting position of the match.
    #[inline]
    pub fn start(&self) -> usize {
        self.start
    }

    /// The ending position of the match.
    #[inline]
    pub fn end(&self) -> usize {
        self.end
    }

    /// Returns true if and only if this match is empty. That is, when
    /// `start() == end()`.
    ///
    /// An empty match can only be returned when the empty string was among
    /// the patterns used to build the Aho-Corasick automaton.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.start == self.end
    }

    #[inline]
    fn offset(&self, by: usize) -> MultiMatch {
        MultiMatch {
            pattern: self.pattern,
            start: self.start + by,
            end: self.end + by,
        }
    }
}

/// An error type indicating that no match could be found.
///
/// Normally, when one searches for something, the response is either an
/// affirmative "it was found at this location" or a negative "not found at
/// all." While the former carries the match offset information (in addition
/// to perhaps the specific pattern that matched, when using a multi-regex
/// engine), the latter typically carries no information other than the fact
/// that nothing could be found. However, due to the lower level nature of this
/// library, it is often useful to know the position at which a search stopped.
///
/// Moreover, in some cases, a search can stop for reasons other than the fact
/// that a match could not be found. For example, the DFAs provided by this
/// library generally cannot correctly implement Unicode word boundaries.
/// Instead, they provide an option to eagerly support them on ASCII text
/// (since Unicode word boundaries are equivalent to ASCII word boundaries when
/// searching ASCII text), but will "give up" if a non-ASCII byte is seen. In
/// such cases, one is usually required to either report the failure to the
/// caller (unergonomic) or otherwise fall back to some other regex engine
/// (ergonomic, but potentially costly).
///
/// More generally, some regex engines offer the ability for callers to specify
/// certain bytes that will trigger the regex engine to automatically quit if
/// they are seen.
///
/// Still yet, there may be other reasons for a failed match. For example,
/// the lazy DFA provided by this crate can be configured to give up if it
/// believes that it is not efficient. This in turn permits callers to choose a
/// different regex engine.
///
/// # Advice
///
/// While this form of error reporting adds complexity, it is generally
/// possible for callers to configure regex engines to not report anything
/// except for a `NoMatchKind::None`. Indeed, the default configuration for
/// every regex engine in this crate is such that only `NoMatchKind::None`
/// will be returned. Therefore, the only way to get a different kind of match
/// error is if the regex engine is explicitly configured to do so. Options
/// that enable this behavior document the new error conditions they imply.
///
/// Regex engines for which no errors are possible for any configuration will
/// return the normal `Option<Match>` and not use this error type at all.
///
/// For example, regex engines in the `dfa` sub-module will only report
/// `NoMatchKind::Quit` if instructed by either enabling Unicode word
/// boundaries or by explicitly specifying one or more quit bytes.
///
/// In cases where `NoMatchKind::None` is guaranteed to be the only error
/// type reported, it is idiomatic to convert a `Result<Match, NoMatch>` to a
/// `Option<Match>`.
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum NoMatch {
    /// The search saw a "quit" byte at which it was instructed to stop
    /// searching.
    Quit {
        /// The "quit" byte that was observed that caused the search to stop.
        byte: u8,
        /// The offset at which the quit byte was observed.
        offset: usize,
    },
    /// The search, based on heuristics, determined that it would be better
    /// to stop, typically to provide the caller an opportunity to use an
    /// alternative regex engine.
    ///
    /// Currently, the only way for this to occur is via the lazy DFA and
    /// only when it is configured to do so (it will not return this error by
    /// default).
    GaveUp {
        /// The offset at which the search stopped. This corresponds to the
        /// position immediately following the last byte scanned.
        offset: usize,
    },
}

// BREADCRUMBS:
//
// I had thought we would want `Result<Match, NoMatch>` for APIs, but this
// turns out to make iterators... weird. We could just squash the Quit or
// GaveUp error types during iteration, but then you could git silent failures
// masquerading as "no match." Alternatively, we would yield the Result, but
// then exposing NoMatch::None as an iterator element doesn't make sense, since
// it's a sentinel value indicating exhaustion.
//
// It looks like what we really want is to remove the NoMatch::None variant
// and use `Option<Result<Match, NoMatch>>` instead. This is much more of a
// mouthful, but I think is a more accurate model. Iterators can then yield the
// `Result<Match, NoMatch>` values.
//
// This is not a simple API. So instead, I think the right way forward is to
// unfortunately go back to the `Option<Match>` API, but then offer `try_*`
// variants of everything that return `Option<Result<Match, NoMatch>>`. The
// non-try variants would panic if a `NoMatch` occurred. This is defensible
// because the default configuration of every regex engine would NEVER return
// a `NoMatch`. The only way it can happen is if the caller opts into it with
// a configuration knob. In which case, they are basically signing up to use
// a more complex API via `try_*`.
//
// What about `Result<Option<Match>, NoMatch>` instead? Then iterators would
// yield `Result<Match, NoMatch>` and callers could more easily do things like
// `re.find_leftmost("...")?` if they really just wanted to not care about the
// error. I'm not sure if that's a good thing, but thinking about it more, it
// feels more natural for the `Result` to be on the outside.

#[cfg(feature = "std")]
impl std::error::Error for NoMatch {}

impl core::fmt::Display for NoMatch {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        match *self {
            NoMatch::Quit { byte, offset } => write!(
                f,
                "quit search after observing byte \\x{:02X} at offset {}",
                byte, offset,
            ),
            NoMatch::GaveUp { offset } => {
                write!(f, "gave up searching at offset {}", offset)
            }
        }
    }
}
